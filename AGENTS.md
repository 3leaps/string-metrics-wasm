# string-metrics-wasm ‚Äì AI Developer Guide

## üîë Read First

- **Prioritize Quality and Reliability**: This library provides high-performance string similarity
  metrics for production applications. All actions must emphasize code quality, test coverage, and
  API stability. Our goal is not rapid commits but ensuring correctness to enable reliable,
  performant string matching in downstream applications. Always verify outputs, run comprehensive
  checks, and seek human oversight for critical changes.
- **Confirm your agentic interface**: If the session does not name an interface adapter (e.g.,
  Claude Code, Cursor, Cline), pause and request guidance from a human maintainer before taking
  action.
- **Review repository safety protocols**: Understand git safety, push authorization requirements,
  and quality gates before executing any operations.

### Known Interface Adapters

| Agentic Interface | Definition Prompt / Rules File                       | Attribution Format                                                                            |
| ----------------- | ---------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| Claude Code       | `AGENTS.md` (this file)                              | `Generated by [Claude Code](https://claude.com/claude-code) under supervision of @3leapsdave` |
| Cursor            | `AGENTS.md` (this file)                              | `Generated by [Cursor](https://cursor.sh/) under supervision of @3leapsdave`                  |
| Cline             | `.cline/rules/PROJECT.md` (must reference this file) | `Generated by [Cline](https://cline.bot/) under supervision of @3leapsdave`                   |
| Windsurf          | `AGENTS.md` (this file)                              | `Generated by [Windsurf](https://codeium.com/windsurf) under supervision of @3leapsdave`      |

**Project**: string-metrics-wasm **Purpose**: High-performance string similarity and fuzzy matching
via WASM bindings to rapidfuzz-rs **Governance**: 3 Leaps Initiative **Repository**:
https://github.com/3leaps/string-metrics-wasm

## Mandatory Reading List

Before making any changes, you **MUST** read these documents in order:

1. **[README.md](README.md)** - Project overview, API reference, quick start, implementation
   approach
2. **[docs/README.md](docs/README.md)** - Documentation hub, core concepts, architecture
3. **[docs/development.md](docs/development.md)** - Development workflow, toolchain, build process,
   fixture validation

Optional but recommended:

- **[docs/publishing.md](docs/publishing.md)** - Release workflow (for maintainers)
- **[Makefile](Makefile)** - Available targets and development commands
- **[similarity-validator/README.md](similarity-validator/README.md)** - Fixture validator tool
  documentation

## Session Startup Protocol

1. **Context Review**
   - **REQUIRED**: Read the mandatory reading list above
   - Review `Makefile` to understand available targets
   - Check git status and current branch
   - Understand that this is a **hybrid Rust/TypeScript project** with WASM bindings

2. **Environment Awareness**
   - Rust toolchain (via rustup) and wasm-pack 0.13.1 required for WASM builds
   - Node.js 18+ for TypeScript builds and tests
   - Version sync enforced between `Cargo.toml` and `package.json`

3. **Plan Before Acting**
   - Outline steps before making changes
   - Use `.plans/` directory (gitignored) for session notes and planning
   - Consider impact on both Rust and TypeScript code

4. **Quality Assurance**
   - Run `make quality` before any commit - it checks formatting and linting
   - Run `make test` to ensure all tests pass
   - Run `make build` to verify WASM and TypeScript builds succeed
   - Validate fixtures with `make validate-fixtures` after changing test cases

5. **Execute Safely**
   - Use Make targets over raw commands
   - Follow version management procedures
   - Test across the hybrid stack (Rust WASM + TypeScript)

## Operational Guidelines

### DO

- **Read Before Write**: ALWAYS use the Read tool on files you expect to exist before using Write or
  Edit. This prevents accidental overwrites and helps you understand existing patterns.
- **List Before Creating**: Use `ls` or Glob to check directory contents before creating new files.
  Ensures you're placing files in the correct location and following existing structure.
- **Use Make Targets**: Prefer `make build`, `make test`, `make quality` over raw tool invocations.
  The Makefile is our primary task orchestrator because it coordinates multiple languages (Rust +
  TypeScript) and ensures reliable task ordering. See "Why We Use Makefile as Primary Task
  Orchestrator" section below for details.
- **Quality Gates First**: Run `make quality` before commits to ensure formatting and linting pass.
- **Version Sync**: Use `make bump-patch|minor|major` or `make set-version VERSION=x.y.z` to keep
  Cargo.toml and package.json synchronized.
- **Test Thoroughly**: Run `make test` before commits. This project has 119+ unit tests and 80+
  fixture cases - they must all pass. See "Test Requirements" below for details.
- **Validate Fixtures**: Run `make validate-fixtures` after modifying test fixtures to ensure
  accuracy against rapidfuzz-rs canonical implementation.
- **Check Coverage**: Run `make test-coverage` to verify test coverage. We maintain high coverage
  standards (90%+ for statements/lines/functions, 70%+ for branches).
- **Follow Language Conventions**: Rust code follows rustfmt/clippy standards. TypeScript follows
  Biome linting/formatting. JSON/YAML/Markdown use Prettier.
- **Respect Naming Conventions**: All APIs must support both camelCase (primary) and snake_case
  (compatibility). When adding new functions or options, implement both naming styles. See "API
  Naming Conventions" section for details on why we support both.
- **Document APIs**: Update README.md when adding new functions. Maintain JSDoc comments for
  TypeScript APIs.
- **Consider Performance**: This library emphasizes performance. Benchmark significant changes with
  `node benchmark-phase1b.js`.
- **Maintain Hybrid Architecture**: Respect the WASM (Rust) vs TypeScript implementation split. WASM
  for raw distance metrics, TypeScript for token-based fuzzy matching.

### DO NOT

- **NEVER Push Without Approval**: üö® Do not execute `git push` without explicit per-instance human
  approval. Always stage and commit locally, then request push authorization.
- **NEVER Force Push**: Do not use `git push --force` or similar force operations. These can cause
  irreversible damage.
- **NEVER Skip Quality Checks**: Do not commit without running `make quality` and `make test` first.
- **NEVER Bypass Makefile for Critical Tasks**: Do not use raw `npm run` or `wasm-pack` commands for
  build/test/quality operations. The Makefile coordinates multiple toolchains correctly. Use
  `make build`, not `npm run build:wasm && npm run build:ts`.
- **NEVER Edit Without Reading**: Do not use Write on existing files without first using Read to
  understand current contents.
- **NEVER Create Files Blindly**: Do not create new files without first checking the directory
  structure and existing patterns.
- **NEVER Modify VERSION Directly**: Use `make bump-*` or `make set-version` commands to update
  versions. Direct edits will cause version drift between Cargo.toml and package.json.
- **NEVER Break Version Sync**: The test suite enforces version consistency. Both files must always
  match.
- **NEVER Commit Build Artifacts**: Do not commit `pkg/`, `dist/`, or `node_modules/`. These are
  generated and gitignored.
- **NEVER Commit .plans/**: The `.plans/` directory is gitignored for local planning only. Do not
  use `-f` to override.
- **NEVER Skip Tests**: All 119+ tests must pass. Do not commit failing tests or skip test runs.
  Using `.skip()` or `.todo()` on test cases requires explicit maintainer approval. See "Test
  Requirements" below.
- **NEVER Lower Coverage Thresholds**: The vitest.config.ts defines minimum coverage thresholds. Do
  not reduce these without maintainer approval.
- **NEVER Add Dependencies Casually**: This is a performance-critical library. New dependencies
  require justification and approval.
- **NEVER Break the API**: This library is published on npm. Breaking changes require careful
  consideration and major version bump.
- **NEVER Ignore Fixture Validation**: If fixture tests fail, investigate and fix. They ensure
  accuracy against the canonical rapidfuzz-rs implementation.

## Project Structure & Architecture

### Hybrid Rust/TypeScript Design

This project uses a carefully designed hybrid approach:

**Rust/WASM (`src/lib.rs`, `pkg/`):**

- Core distance metrics: Levenshtein, Damerau-Levenshtein, OSA, Jaro, Jaro-Winkler
- RapidFuzz metrics: ratio, indel*\*, lcs_seq*\*
- Maximum performance via compiled WASM

**TypeScript (`src/index.ts`, `dist/`):**

- Token-based fuzzy matching: partialRatio, tokenSortRatio, tokenSetRatio
- Process helpers: extractOne, extract
- Unified API: distance(), score()
- Normalization and suggestions
- Avoids WASM serialization overhead for array operations

### Key Files and Directories

- `src/lib.rs` - Rust WASM bindings and exports
- `src/index.ts` - TypeScript facade and higher-level APIs
- `pkg/` - Generated WASM output from wasm-pack (gitignored)
- `dist/` - Compiled TypeScript output (gitignored)
- `tests/` - Vitest test suite
- `tests/fixtures/v2.0.0/` - YAML test fixtures organized by topic
- `similarity-validator/` - Rust CLI for validating fixtures against rapidfuzz-rs
- `schemas/` - JSON schema for fixture structure
- `Makefile` - Development workflow automation

### Why We Use Makefile as Primary Task Orchestrator

**This project uses a Makefile as the primary task orchestrator for several critical reasons:**

1. **Multi-Language Coordination**: We have multiple toolchains (Rust/wasm-pack, Node.js/npm,
   TypeScript) that need to work together. Make provides a single, consistent interface across all
   of them.

2. **Reliable Task Ordering**: Make ensures tasks run in the correct order with proper dependency
   tracking. For example, `make build` ensures WASM builds before TypeScript compilation, and
   version checks happen before tests.

3. **Cross-Platform Consistency**: Make targets work the same way across macOS, Linux, and Windows
   (with WSL), ensuring consistent behavior in local development and CI/CD.

4. **Quality Gate Enforcement**: Make targets like `make quality`, `make test`, and
   `make prepublish` encode best practices and prevent common mistakes.

**Best Practice**: Always prefer Make targets over raw npm scripts in normal operation. Use
`make build` instead of `npm run build:wasm && npm run build:ts`, `make test` instead of `npm test`,
etc. The Makefile handles the complexity of coordinating multiple build systems correctly.

### API Naming Conventions

**This project follows a dual naming convention to support multiple use cases:**

**Primary Convention (camelCase)**:

- All TypeScript APIs use camelCase: `jaroWinkler()`, `tokenSortRatio()`, `extractOne()`
- Options use camelCase: `scoreCutoff`, `minScore`, `maxSuggestions`
- Metric names use camelCase: `'jaroWinkler'`, `'damerauLevenshtein'`, `'partialRatio'`

**Compatibility Convention (snake_case)**:

- All APIs also accept snake_case as aliases: `jaro_winkler`, `token_sort_ratio`, `extract_one`
- Options accept snake_case: `score_cutoff`, `min_score`, `max_suggestions`
- Metric names accept snake_case: `'jaro_winkler'`, `'damerau_levenshtein'`, `'partial_ratio'`

**Why Both?**

- camelCase aligns with JavaScript/TypeScript ecosystem conventions
- snake_case supports multi-language applications (particularly the Fulmen/Crucible ecosystem) where
  cross-language consistency requires snake_case conventions
- The library automatically normalizes snake_case to camelCase internally

**Implementation Notes for AI Developers**:

- When adding new APIs, always support both naming styles
- Test files use snake_case in YAML fixtures (cross-language compatibility)
- TypeScript test code uses type assertions when converting fixture strings to typed metric enums
- The codebase includes normalization functions that handle the conversion

### Test Requirements

**This project maintains strict testing standards to ensure reliability and correctness:**

**100% Test Pass Rate (Mandatory)**:

- All 119+ unit tests MUST pass before any commit
- All 80+ YAML fixture test cases MUST pass
- Zero tolerance for failing tests in commits
- Test skips (`.skip()`, `.todo()`, `it.only()`) require explicit maintainer approval

**Coverage Standards**:

- **Statements**: 90%+ coverage required
- **Lines**: 90%+ coverage required
- **Functions**: 90%+ coverage required
- **Branches**: 70%+ coverage required (lower due to error handling branches)

**Coverage Verification**:

```bash
make test-coverage          # View detailed coverage report
```

Coverage is configured in `vitest.config.ts` and enforced during test runs. Lowering thresholds
requires maintainer approval and documented justification.

**Fixture Validation**:

- All YAML fixtures must validate against the canonical rapidfuzz-rs implementation
- Run `make validate-fixtures` after modifying test fixtures
- Fixture validator is a Rust CLI tool that ensures our TypeScript implementation matches
  rapidfuzz-rs exactly

**When Adding New Features**:

1. Write tests FIRST (TDD approach preferred)
2. Ensure tests cover both camelCase and snake_case API variants
3. Add corresponding YAML fixtures for cross-language compatibility
4. Verify coverage meets or exceeds thresholds
5. Validate fixtures with `make validate-fixtures`

**Test Organization**:

- Unit tests: `tests/index.test.ts`
- Fixtures: `tests/fixtures/v2.0.0/*.yaml`
- Organized by category (basic, unicode, multiline, normalization, substring, suggestions)

**Why These Standards?**:

- Published on npm - users depend on correctness
- High-performance library - regressions are costly
- Cross-language compatibility - fixtures ensure consistency
- Enterprise quality - zero surprises in production

## Development Workflow

### Common Tasks

```bash
# Bootstrap (first time setup)
make bootstrap              # Install tools and dependencies

# Build
make build                  # Build WASM + TypeScript (with version check)
npm run build:wasm          # Build only WASM
npm run build:ts            # Build only TypeScript

# Quality & Testing
make quality                # Format check + lint (Biome, Prettier, rustfmt, clippy)
make test                   # Run test suite (119+ tests)
make test-coverage          # Run tests with coverage report
make format                 # Auto-format all code
make lint                   # Lint TypeScript
make lint-fix               # Lint and auto-fix

# Fixture Validation
make build-validator        # Build the fixture validator
make validate-fixtures      # Validate all YAML fixtures

# Version Management
make version-check          # Verify Cargo.toml and package.json match
make bump-patch             # 0.3.4 -> 0.3.5
make bump-minor             # 0.3.4 -> 0.4.0
make bump-major             # 0.3.4 -> 1.0.0
make set-version VERSION=x.y.z  # Set explicit version

# Cleanup
make clean                  # Remove build artifacts
```

### Pre-Commit Checklist

Before committing ANY changes:

1. ‚úÖ Run `make quality` - all checks must pass
2. ‚úÖ Run `make test` - all 119+ tests must pass (100% pass rate required)
3. ‚úÖ Run `make test-coverage` - verify coverage meets thresholds (optional but recommended)
4. ‚úÖ Run `make validate-fixtures` if you touched fixtures
5. ‚úÖ Run `make version-check` if you touched version files
6. ‚úÖ Review `git status` - understand what's being committed
7. ‚úÖ Write clear commit message following conventions
8. ‚úÖ Do NOT push - request approval first

## Commit Attribution

All commits should include proper attribution to maintain project history and accountability.

**Example commit message:**

```
feat: add new string similarity metric

Implemented Hamming distance for fixed-length string comparison.
Added tests and updated API documentation.

Generated by [Claude Code](https://claude.com/claude-code) under supervision of @3leapsdave

Co-Authored-By: Claude Code <noreply@anthropic.com>
```

**Key elements:**

1. Conventional commit prefix (feat, fix, docs, test, refactor, etc.)
2. Clear description of changes and rationale
3. Attribution line with interface and supervisor
4. Co-authored-by trailer

## Git Operation Safety

### Push Authorization

**üö® CRITICAL**: AI developers are NEVER authorized to push code to remote repositories without
explicit, per-instance human approval.

**Allowed operations:**

```bash
git status              # ‚úÖ Check repository state
git add <files>         # ‚úÖ Stage changes
git commit              # ‚úÖ Commit locally
git log                 # ‚úÖ Review history
git diff                # ‚úÖ Review changes
```

**Forbidden operations without approval:**

```bash
git push                # ‚ùå NEVER without explicit approval
git push --force        # ‚ùå CATASTROPHIC - never use
git push origin main    # ‚ùå Requires approval
```

**Push approval process:**

1. Complete all work and commits locally
2. Run all quality checks and tests
3. Request explicit push approval from human maintainer
4. Wait for approval confirmation
5. Only then execute push with documented approval

### .gitignore Respect

**NEVER override gitignore rules**:

- If git warns about ignored files, STOP immediately
- Do not use `-f`, `--force`, or any bypass flags
- `.plans/` is gitignored for a reason (local planning only)
- Build artifacts (`pkg/`, `dist/`, `node_modules/`) must never be committed
- Consult with human supervisor if you believe a gitignored file should be committed

## Testing & Quality Standards

### Test Coverage

- **119+ unit tests** covering all functions
- **80+ YAML fixture test cases** for reproducibility
- **100% regression-free** target across releases
- Fixtures validated against canonical rapidfuzz-rs implementation

### Quality Tools

- **Biome**: TypeScript/JavaScript linting and formatting
- **Prettier**: JSON, YAML, Markdown formatting
- **rustfmt**: Rust code formatting
- **clippy**: Rust linting
- **Vitest**: Test runner with coverage

### Fixture Organization

Fixtures live in `tests/fixtures/v2.0.0/` organized by topic:

- `basic.yaml` - Core metrics (Levenshtein, Damerau, Jaro-Winkler)
- `unicode.yaml` - Emoji, CJK, accents, locale-specific
- `multiline.yaml` - Newlines, CRLF, line endings
- `normalization.yaml` - Normalization preset tests
- `substring.yaml` - Substring similarity (LCS-based)
- `suggestions.yaml` - Suggestion API tests

## Design Principles

### Performance First

- All operations target < 1ms completion time
- WASM metrics: 0.0003-0.0005ms per operation
- Token metrics: 0.0003-0.0017ms per operation
- Benchmark significant changes

### API Stability

- Published on npm - breaking changes require major version bump
- Support both camelCase (primary) and snake_case (compatibility alias)
- Maintain backward compatibility whenever possible

### Multi-Runtime Support

- Node.js 16+ (ESM and CommonJS)
- Bun (native ESM)
- Deno (npm: specifier)

### Enterprise Quality

- Comprehensive test coverage
- Clear documentation
- Predictable performance
- No surprises in production

## Reference Documents

All project documentation is located in the `docs/` directory:

- `docs/README.md` - Documentation overview and navigation
- `docs/development.md` - Development guide and workflow
- `docs/publishing.md` - Release and publishing procedures
- `similarity-validator/README.md` - Fixture validator documentation

Additional resources:

- Main `README.md` - API reference and usage examples
- `Makefile` - Available commands and targets
- `CHANGELOG.md` - Version history and release notes
- Governance documents: https://github.com/3leaps/oss-policies/

## Contributing Philosophy

When working on string-metrics-wasm, remember:

- **Quality over speed** - Correct, performant, maintainable code
- **Test everything** - No untested code reaches production
- **Document changes** - Future developers (including AI) need clear context
- **Respect the architecture** - WASM for primitives, TypeScript for composition
- **Performance matters** - This is a performance-critical library
- **Users depend on stability** - Breaking changes disrupt downstream applications

## Getting Help

- Review the mandatory reading list first
- Check existing code patterns and tests
- Consult with human supervisor for architectural questions
- When in doubt, ask before making significant changes

---

**Last Updated**: 2025-10-31 **Status**: v0.3.4 - RapidFuzz-aligned API with TypeScript extensions

_This guide is for AI developers working on string-metrics-wasm. For human contributor information,
see CONTRIBUTING.md (when available) or contact @3leapsdave._
